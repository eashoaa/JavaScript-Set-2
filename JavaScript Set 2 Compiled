/**
 * Shift by letter
 *
 * Shift a letter to the right using the number equivalent of another letter.
 * The shift letter is any letter from A to Z, where A represents 0, B represents 1, ..., Z represents 25.
 *
 * @param {string} letter A single uppercase English letter, or a space
 * @param {string} letterShift A single uppercase English letter
 * @returns {string} The letter, shifted appropriately
 */
function shiftByLetter(letter, letterShift) {
    if (letter === ' ') return ' ';

    let shiftValue = letterShift.charCodeAt(0) - 'A'.charCodeAt(0);
    let newCharCode = letter.charCodeAt(0) + shiftValue;

    if (newCharCode > 'Z'.charCodeAt(0)) {
        newCharCode = newCharCode - 26;
    }

    return String.fromCharCode(newCharCode);
}

/**
 * Scytale cipher
 *
 * Encrypts a message by simulating a scytale cipher.
 *
 * @param {string} message A string of uppercase English letters and underscores. Underscores represent spaces.
 * @param {number} shift A positive integer that does not exceed the length of the message
 * @returns {string} The encoded message using the scytale cipher
 */
function scytaleCipher(message, shift) {
    let messageLength = message.length;
    let remainder = messageLength % shift;

    if (remainder !== 0) {
        let padding = shift - remainder;
        message += '_'.repeat(padding);
        messageLength = message.length;
    }

    let encodedMessage = '';
    let numRows = messageLength / shift;

    for (let i = 0; i < messageLength; i++) {
        let row = Math.floor(i / shift);
        let col = i % shift;
        let index = col * numRows + row;

        encodedMessage += message[index];
    }

    return encodedMessage;
}

/**
 * Scytale decipher
 *
 * Decrypts a message that was originally encrypted with the `scytaleCipher` function above.
 *
 * @param {string} message A string of uppercase English letters and underscores. Underscores represent spaces.
 * @param {number} shift A positive integer that does not exceed the length of the message
 * @returns {string} The deciphered message
 */
function scytaleDecipher(message, shift) {
    let numRows = Math.ceil(message.length / shift);
    let decipheredMessage = '';

    for (let col = 0; col < shift; col++) {
        for (let row = 0; row < numRows; row++) {
            let index = row * shift + col;
            if (index < message.length) {
                decipheredMessage += message[index];
            }
        }
    }

    return decipheredMessage;
}

/**
 * Vigenere cipher
 *
 * Encrypt a message using a keyphrase instead of a static number.
 * Every letter in the message is shifted by the number represented by the respective letter in the key.
 *
 * @param {string} message A string of uppercase English letters and/or spaces
 * @param {string} key A string of uppercase English letters, no spaces. Will not exceed the length of the message.
 * @returns {string} The message, shifted appropriately
 */
function vigenereCipher(message, key) {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    function shiftChar(char, keyChar) {
        const charIndex = alphabet.indexOf(char);
        const keyIndex = alphabet.indexOf(keyChar);
        return alphabet[(charIndex + keyIndex) % 26];
    }

    let encryptedMessage = "";
    let keyIndex = 0;

    for (let i = 0; i < message.length; i++) {
        if (message[i] === " ") {
            encryptedMessage += " ";
        } else {
            encryptedMessage += shiftChar(message[i], key[keyIndex % key.length]);
            keyIndex++;
        }
    }

    return encryptedMessage;
}
